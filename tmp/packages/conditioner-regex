{"_id":"conditioner-regex","_rev":"2-0f697197eb05eaa7ef60dfd8de9a7e57","name":"conditioner-regex","description":"Convert sets of semantic key/vale conditions to regex capture groups","dist-tags":{"latest":"0.1.2"},"versions":{"0.1.0":{"name":"conditioner-regex","version":"0.1.0","description":"Convert sets of semantic key/vale conditions to regex capture groups","main":"dist/index.js","scripts":{"test":"gulp test","coveralls":"gulp test && cat coverage/lcov.info | ./node_modules/coveralls/bin/coveralls.js","docs":"docco src/*.coffee","dist":"coffee -c -o dist/ src/"},"repository":{"type":"git","url":"git+ssh://git@github.com/timkinnane/conditioner.git"},"keywords":["regex","hubot","string","comparison","capture","utility"],"author":{"name":"Tim Kinnane","email":"tim@nestedcode.com"},"license":"MIT","bugs":{"url":"https://github.com/timkinnane/conditioner/issues"},"homepage":"https://github.com/timkinnane/conditioner#readme","dependencies":{"coffee-script":"^1.9.0","underscore":"^1.8.3","yamljs":"^0.2.8"},"devDependencies":{"boolify-string":"^0.1.0","chai":"^3.5.0","coveralls":"^2.10.1","del":"^1.1.1","docco":"^0.7.0","event-stream":"^3.1.5","gulp":"^3.8.2","gulp-coffee":"^2.0.1","gulp-coffeelint":"^0.4.0","gulp-espower":"^0.10.0","gulp-if":"^1.2.1","gulp-istanbul":"^0.6.0","gulp-load-plugins":"^0.8.0","gulp-mocha":"^2.0.0","gulp-plumber":"^0.6.3","gulp-sourcemaps":"^1.3.0","gulp-util":"^3.0.3","power-assert":"^0.10.1","sinon":"^1.10.2"},"gitHead":"aa8d182d75b75e466315a76c8b0b9482ffc86121","_id":"conditioner-regex@0.1.0","_shasum":"7bc201b88186d2c0a6065b2ef76ce344fec7ffca","_from":".","_npmVersion":"2.15.9","_nodeVersion":"4.6.0","_npmUser":{"name":"timkinnane","email":"tim@nestedcode.com"},"dist":{"shasum":"7bc201b88186d2c0a6065b2ef76ce344fec7ffca","tarball":"http://registry.npmjs.org/conditioner-regex/-/conditioner-regex-0.1.0.tgz"},"maintainers":[{"name":"timkinnane","email":"tim@nestedcode.com"}],"_npmOperationalInternal":{"host":"packages-12-west.internal.npmjs.com","tmp":"tmp/conditioner-regex-0.1.0.tgz_1476420306420_0.58503865939565"}},"0.1.1":{"name":"conditioner-regex","version":"0.1.1","description":"Convert sets of semantic key/vale conditions to regex capture groups","main":"dist/index.js","scripts":{"test":"gulp test","coveralls":"gulp test && cat coverage/lcov.info | ./node_modules/coveralls/bin/coveralls.js","docs":"docco src/*.coffee","dist":"coffee -c -o dist/ src/"},"repository":{"type":"git","url":"git+ssh://git@github.com/timkinnane/conditioner.git"},"keywords":["regex","hubot","string","comparison","capture","utility"],"author":{"name":"Tim Kinnane","email":"tim@nestedcode.com"},"license":"MIT","bugs":{"url":"https://github.com/timkinnane/conditioner/issues"},"homepage":"https://github.com/timkinnane/conditioner#readme","dependencies":{"coffee-script":"^1.9.0","underscore":"^1.8.3","yamljs":"^0.2.8"},"devDependencies":{"boolify-string":"^0.1.0","chai":"^3.5.0","coveralls":"^2.10.1","del":"^1.1.1","docco":"^0.7.0","event-stream":"^3.1.5","gulp":"^3.8.2","gulp-coffee":"^2.0.1","gulp-coffeelint":"^0.4.0","gulp-espower":"^0.10.0","gulp-if":"^1.2.1","gulp-istanbul":"^0.6.0","gulp-load-plugins":"^0.8.0","gulp-mocha":"^2.0.0","gulp-plumber":"^0.6.3","gulp-sourcemaps":"^1.3.0","gulp-util":"^3.0.3","power-assert":"^0.10.1","sinon":"^1.10.2"},"gitHead":"9be2284dddb6652f8ad5eb967ff05c61b4f22855","_id":"conditioner-regex@0.1.1","_shasum":"49daa062964c21f72bcce5e915d26e6fdaa9e559","_from":".","_npmVersion":"2.15.9","_nodeVersion":"4.6.0","_npmUser":{"name":"timkinnane","email":"tim@nestedcode.com"},"dist":{"shasum":"49daa062964c21f72bcce5e915d26e6fdaa9e559","tarball":"http://registry.npmjs.org/conditioner-regex/-/conditioner-regex-0.1.1.tgz"},"maintainers":[{"name":"timkinnane","email":"tim@nestedcode.com"}],"_npmOperationalInternal":{"host":"packages-16-east.internal.npmjs.com","tmp":"tmp/conditioner-regex-0.1.1.tgz_1476422758439_0.3159837299026549"}},"0.1.2":{"name":"conditioner-regex","version":"0.1.2","description":"Convert sets of semantic key/vale conditions to regex capture groups","main":"dist/index.js","scripts":{"test":"gulp test","coveralls":"gulp test && cat coverage/lcov.info | ./node_modules/coveralls/bin/coveralls.js","docs":"docco src/*.coffee","dist":"coffee -c -o dist/ src/"},"repository":{"type":"git","url":"git+ssh://git@github.com/timkinnane/conditioner.git"},"keywords":["regex","hubot","string","comparison","capture","utility"],"author":{"name":"Tim Kinnane","email":"tim@nestedcode.com"},"license":"MIT","bugs":{"url":"https://github.com/timkinnane/conditioner/issues"},"homepage":"https://github.com/timkinnane/conditioner#readme","dependencies":{"underscore":"^1.8.3"},"devDependencies":{"coffee-script":"^1.9.0","boolify-string":"^0.1.0","chai":"^3.5.0","coveralls":"^2.10.1","del":"^1.1.1","docco":"^0.7.0","event-stream":"^3.1.5","gulp":"^3.8.2","gulp-coffee":"^2.0.1","gulp-coffeelint":"^0.4.0","gulp-espower":"^0.10.0","gulp-if":"^1.2.1","gulp-istanbul":"^0.6.0","gulp-load-plugins":"^0.8.0","gulp-mocha":"^2.0.0","gulp-plumber":"^0.6.3","gulp-sourcemaps":"^1.3.0","gulp-util":"^3.0.3","power-assert":"^0.10.1","sinon":"^1.10.2"},"gitHead":"ab53936d9cb4392609a1ac5ed11c3edcb942c30e","_id":"conditioner-regex@0.1.2","_shasum":"9ae8b373dad8d40ee80ccc132d898236b799c701","_from":".","_npmVersion":"2.15.9","_nodeVersion":"4.6.0","_npmUser":{"name":"timkinnane","email":"tim@nestedcode.com"},"dist":{"shasum":"9ae8b373dad8d40ee80ccc132d898236b799c701","tarball":"http://registry.npmjs.org/conditioner-regex/-/conditioner-regex-0.1.2.tgz"},"maintainers":[{"name":"timkinnane","email":"tim@nestedcode.com"}],"_npmOperationalInternal":{"host":"packages-16-east.internal.npmjs.com","tmp":"tmp/conditioner-regex-0.1.2.tgz_1476423498048_0.24156058370135725"}}},"readme":"![Conditioner - Regex in a bottle](https://raw.githubusercontent.com/timkinnane/conditioner/master/assets/logo.png)\n\n[![NPM version][npm-image]][npm-url]\n\n> NB: This is a beta release, features are stable but documentation and coverage is incomplete.\n\n## What it do?\n\nConditioner provides semantic conditions for string comparison and capture.\n\nIt isn't intended to replace the full power of regex, just simplify it for some\ncommon use cases.\n\nIt was developed specifically for messanging and chat-bot scripts, to compare conversational streams against listeners and capture user inputs with easy to reference keys.\n\n---\n\n## Options / Defaults\n\n### `matchWords: true`\n\nOnly whole words are matched, so words like \"whoever\" won't trigger false positives if \"who\" is what we're looking for.\n\n### `ignoreCase: true`\n\nConditions are case insensitive by default\n\n### `ignorePunctuation: true`\n\nPunctuation is stripped from inputs by default, so that messages like \"Hello World!\" and \"hello, world\" can be treated equally.\n\n### `escapeValues: false`\n\nBy default, conditions won't escape special characters, so regex can be used within conditions to enhance capturing.\n\ne.g. `contains: 'coffee(s)?'` will match \"A coffee\" and \"1000 coffees\".\n\nSet to true if you actually need to match against special characters.\n\n## Condition Types\n\n- `is` matches the entire string\n- `starts` matches the start\n- `ends` matches the end\n- `contains` matches a segment\n- `excludes` negative match a segment\n- `after` matches following a segment\n- `before` matches preceding segment\n- `range` matches a number range\n\n---\n\n## Usage\n\n> NB: It's written in coffee-script so that's what I use in demos, however the dist is compiled to js\n\nInstall: `npm install conditioner-regex --save`\n\nRequire: `Conditioner = require 'conditioner-regex'`\n\nInitialize: `new Conditioner( [conditions[, options]] )`\n\nOr (optionally) with some conditions and options...\n\n```coffeescript\nc = new Conditioner\n  starts: 'who'\n  ends: '?'\n,\n  escapeValues: true\n  ignorePunctuation: false\n```\n\nWould match any string that *starts* with \"who\" and *ends* in a question mark.\n\nConditions can be passed as an array or an object.\n\n### `.add( condition[, key] )`\n\nAdds further conditions and can be chained on the constructor.\nYou can also add regex objects or strings containing regex patterns as conditions.\n\n```coffeescript\nre = new RegExp /test/, 'i'\nc.add re, 'regexp'\nc.add /test/i, 'regexpString'\nc.add is: 'test', 'regexpCondition'\n```\n\nThe above creates three identical conditions, match results can be accessed by their keys.\n\n### `.expressions`\n\nObject keeping passed conditions, each converted to regex.\n\n### `.compare( string )`\n\nCompares the string against *all* loaded conditions. e.g. Looking for _\"Who... ?\"_\n\n```coffeescript\nc.compare 'Who goes there?'\n# returns true\n\nc.compare 'Who? Tis I!'\n# returns false\n```\n\n### `.capture( string )`\n\nCaptures and returns the parts of the string that match each condition. e.g.\n\n```coffeescript\nc = new Conditioner\n  after: \"name is\"\n  range: \"1-99\"\n\nc.capture \"My name is Isaac, I'm 72\"\n# returns { 0: 'Isaac', 1: '72' }\n```\n\n### `.compared` and `.captured`\n\nKeeps the results of each condition for the last comparison/capture.\n\n### `.matches`\n\nKeeps the full returned results for a standard regex match\n\n### `.clear()`\n\nClears the compare or capture results, leaving existing conditions.\n\n### `.clearAll()`\n\nClears results and conditions.\n\n---\n\n## Full Example\n\n```coffeescript\n\n# determine replies to an array of coffee (or possibly not) orders\nreplyToOrders = (orders) ->\n\n  # order conditions for validity\n  validity = new Conditioner()\n    .add starts: 'order|get'\n    .add contains: 'coffee(s)?', 'coffeePlural'\n    .add excludes: 'not'\n\n  # order details\n  deets = new Conditioner()\n    .add contains: 'me', 'forSelf'\n    .add range: '1-999', 'qty'\n    .add after: 'for', 'for'\n    .add ends: 'please', 'polite'\n\n  orders.map (order) ->\n    detail = deets.capture order # capture details\n    valid = validity.compare order # test validity\n\n    # get parts\n    coffeePlural = validity.matches.coffeePlural?[0] # coffee, coffees or undefined\n    qty = detail.qty ? '1'\n    who = if detail.forSelf then \"you\" else detail.for ? \"I dunno?\"\n    polite = if detail.polite then yes else no\n\n    # compose\n    switch\n      when valid and polite\n        \"#{ qty } #{ coffeePlural } for #{ who }. Have a nice day :)\"\n      when valid\n        \"#{ qty } #{ coffeePlural } for #{ who }\"\n      when not valid and polite\n        \"Sorry, no.\"\n      else\n        \"No coffee for you.\"\n\n# coffee orders, input received\norders = [\n  'Order me a coffee please'\n  'Order 2 coffees for Otis'\n  'Get me 100 coffees'\n  'Order Borat 10 coffees please... NOT!'\n  'Order me a horse, please'\n  'I love lamp'\n]\n\nconsole.log replyToOrders orders\n\n###\nOutputs:\n[ '1 coffee for you. Have a nice day :)',\n  '2 coffees for Otis',\n  '100 coffees for you',\n  'No coffee for you.',\n  'Sorry, no.',\n  'No coffee for you.' ]\n###\n\n```\n\n---\n\nDownload and open /docs for docco generated code comments for further detail.\n\n[npm-url]: https://npmjs.org/package/conditioner-regex\n[npm-image]: http://img.shields.io/npm/v/conditioner-regex.svg?style=flat\n","maintainers":[{"name":"timkinnane","email":"tim@nestedcode.com"}],"time":{"modified":"2016-10-14T05:38:20.229Z","created":"2016-10-14T04:45:06.667Z","0.1.0":"2016-10-14T04:45:06.667Z","0.1.1":"2016-10-14T05:26:00.643Z","0.1.2":"2016-10-14T05:38:20.229Z"},"homepage":"https://github.com/timkinnane/conditioner#readme","keywords":["regex","hubot","string","comparison","capture","utility"],"repository":{"type":"git","url":"git+ssh://git@github.com/timkinnane/conditioner.git"},"author":{"name":"Tim Kinnane","email":"tim@nestedcode.com"},"bugs":{"url":"https://github.com/timkinnane/conditioner/issues"},"license":"MIT","readmeFilename":"README.md"}
