{"_id":"hubot-questionnaire-framework","_rev":"1-0b43e8b31a13b76b6c672ce946478041","name":"hubot-questionnaire-framework","dist-tags":{"latest":"1.0.2"},"versions":{"1.0.1":{"name":"hubot-questionnaire-framework","version":"1.0.1","description":"Hubot Questionnaire Framework","main":"src/questionnaire.js","scripts":{"test":"echo \"Error: no test specified\" && exit 1"},"repository":{"type":"git","url":"git+https://github.com/Alterdesk/hubot-questionnaire-framework.git"},"author":{"name":"Alterdesk"},"license":"MIT","dependencies":{"express":"^4.17.1","form-data":"^2.5.0","hubot":"^3.3.2","js-levenshtein":"^1.1.6","mkdirp":"^0.5.1","moment":"^2.24.0","moment-timezone":"^0.5.26","node-messenger-log":"^1.0.0","request":"^2.88.0","uuid":"^3.3.3"},"gitHead":"087c5163f321f3fea3d5895827a10b7e76e6de51","bugs":{"url":"https://github.com/Alterdesk/hubot-questionnaire-framework/issues"},"homepage":"https://github.com/Alterdesk/hubot-questionnaire-framework#readme","_id":"hubot-questionnaire-framework@1.0.1","_npmVersion":"6.4.1","_nodeVersion":"8.10.0","_npmUser":{"name":"developer_alterdesk","email":"info@alterdesk.com"},"dist":{"integrity":"sha512-fy+xfVErOYz+Zf77nYwdkhhC649txmgy2XLRmamG7YRFNvFa/O7+jCLTIbUAqVtZJcHDaaGU/pc1Ft52NvxiKQ==","shasum":"31cc056a762074558b21b457232cecb8ca56484b","tarball":"https://registry.npmjs.org/hubot-questionnaire-framework/-/hubot-questionnaire-framework-1.0.1.tgz","fileCount":83,"unpackedSize":459372,"npm-signature":"-----BEGIN PGP SIGNATURE-----\r\nVersion: OpenPGP.js v3.0.4\r\nComment: https://openpgpjs.org\r\n\r\nwsFcBAEBCAAQBQJep/tzCRA9TVsSAnZWagAAG7oP/jAkoEeHwtu2bWCg2tX0\nbSPYP/fIJglCoaz3DPo2ElHM5OIevwf847bn4Ikeyt8pWautc5wfUGCDD1uN\nl0A0IJ8WCOJzviamneYl3m88bTpbK96D3zXjzXIh3V04UDTflFf4UIV2leQ1\nBojZAozPOl6HDqF9FJSRzlS21S5y7yesl+TxIPkeVFv5fSwKaU1AHlRvET9y\nzJcO5Z/8lZjOQPa4PD3eT5PvC6aDjw+1eVzJ8rUCZG+NBsurS1WMprzaevmw\ndh089Vju6ZAl0UwdtyvZ9Nbq14ZNLwa0k3xQJ3f6mzXyO7ep2f8tCkg9eF3E\n9Up1SQkCm7Wf0xGZkjdunyWc7VTIvDd0uyJXArrH19czimBMkI0abtevZwZ9\nkikq1nUA4atfD+Br64emxNLJx0ppqMxWlGhONlQBwQW4Bv4BQMky8+CsZZ/R\nw3P7Sqmsn6lQPMlbC/MWYoJtLIQJgDvay8FuCdZ7mAky9VbeweY+D+Y/OJqC\n/42W8Gd1WUN0XZt0JMnnmLg5dNTZs5X0yCh/7iKYTwA6xt16ce2SfY1z6HcY\n2L0e5OtnmM4x2lopQaYwZLhL/CHNHFftQmrqLApeINMKJ7WzEufq6b4mDFAP\nPC2xq7GzJ+2/QjPmqoXRMI5MSb7qq7jZKLd59jdMcxustz0ypmRFlqcx2AZv\nAyrF\r\n=Yo15\r\n-----END PGP SIGNATURE-----\r\n"},"maintainers":[{"name":"developer_alterdesk","email":"info@alterdesk.com"}],"directories":{},"_npmOperationalInternal":{"host":"s3://npm-registry-packages","tmp":"tmp/hubot-questionnaire-framework_1.0.1_1588067186727_0.7572950185681679"},"_hasShrinkwrap":false},"1.0.2":{"name":"hubot-questionnaire-framework","version":"1.0.2","description":"Hubot Questionnaire Framework","main":"src/questionnaire.js","scripts":{"test":"echo \"Error: no test specified\" && exit 1"},"repository":{"type":"git","url":"git+https://github.com/Alterdesk/hubot-questionnaire-framework.git"},"author":{"name":"Alterdesk"},"license":"MIT","dependencies":{"express":"^4.17.1","form-data":"^2.5.0","hubot":"^3.3.2","js-levenshtein":"^1.1.6","mkdirp":"^0.5.1","moment":"^2.24.0","moment-timezone":"^0.5.26","node-messenger-log":"^1.0.0","request":"^2.88.0","uuid":"^3.3.3"},"gitHead":"3360c4e165fd2baa265186cb39b4c380ead88e94","bugs":{"url":"https://github.com/Alterdesk/hubot-questionnaire-framework/issues"},"homepage":"https://github.com/Alterdesk/hubot-questionnaire-framework#readme","_id":"hubot-questionnaire-framework@1.0.2","_npmVersion":"6.4.1","_nodeVersion":"8.10.0","_npmUser":{"name":"developer_alterdesk","email":"info@alterdesk.com"},"dist":{"integrity":"sha512-xuziTWFeOAs1eCBc8LuraWmZH0igHkK0jj6HmJkvpqn/UFrBNZDIGOPHv4T0DZgnKg/PmS78rNL2W/Tu8j0Mvw==","shasum":"33510d9751ed26c80320a27ecc166c0962e9e971","tarball":"https://registry.npmjs.org/hubot-questionnaire-framework/-/hubot-questionnaire-framework-1.0.2.tgz","fileCount":84,"unpackedSize":462439,"npm-signature":"-----BEGIN PGP SIGNATURE-----\r\nVersion: OpenPGP.js v3.0.4\r\nComment: https://openpgpjs.org\r\n\r\nwsFcBAEBCAAQBQJe9J2dCRA9TVsSAnZWagAAY5IP/jyz2Am/N13eXkE79dWc\nydasuSnVoHTDAaukP6fi78PVO7dj0ydY4hVcPPFODAFW+ag/nO7Hty+gFaWH\nUbv3o/N0zbaWFXaFrNS2lOszTgEqXuQQ6wux86o3vvvRlcFjzLKSDuN1WgE/\nNfW/3DxXjN8Vr2rax1TvaX2kEusG5YPdBF33UfoIEqLS95WDMMr+j3X0fHRf\neCYjXEdSMgJ3dYEM+dgKIRyErjh91F7TI5BtwweeHwJbGnNP+tEez4CXTyVM\nfF3rmw5VAL+o/y7JQn+bA7PZue0ZeOHzzlBY8cg2R95PgFE5SGb1fDXycaFA\nCPo6KypC7ovYKxV3Em2xuskP6ODRhlFRadxQZM5XRlWkGtBfnXR/zDKGEm3K\nZiF6LCfVCWfphC8qE3ItJi4iYYVOIOhFoi/k31gbiLBt3tEJ2HFr5dVR9KOS\nbK/qmQ5McwJKVrkwSSuvgDYp9i97QWlGYSVNoDSrzKagrrSK6Zi1H9Y0E6pR\n49392Fzx40UlQXozP3vDcwWmXg3M4KktP0ODcjIlTQFaFmwJRjhAIYH+KZlk\nIu5nn9FCAmUMAQUFyq7HIAWaKikmDVcm0eaKEmLGDtLqyzuPon2nlAs++XQT\nXvlHPSt9efpm0HGdFNriuqhFk8P3Zwl7LR3NIq6+EDn7PtLED3wq51mot2aL\ngr4R\r\n=tQUJ\r\n-----END PGP SIGNATURE-----\r\n"},"maintainers":[{"name":"developer_alterdesk","email":"info@alterdesk.com"}],"directories":{},"_npmOperationalInternal":{"host":"s3://npm-registry-packages","tmp":"tmp/hubot-questionnaire-framework_1.0.2_1593089437007_0.2996734984931284"},"_hasShrinkwrap":false}},"time":{"created":"2020-04-28T09:46:26.726Z","1.0.1":"2020-04-28T09:46:26.899Z","modified":"2020-06-25T12:50:39.570Z","1.0.2":"2020-06-25T12:50:37.157Z"},"maintainers":[{"name":"developer_alterdesk","email":"info@alterdesk.com"}],"description":"Hubot Questionnaire Framework","homepage":"https://github.com/Alterdesk/hubot-questionnaire-framework#readme","repository":{"type":"git","url":"git+https://github.com/Alterdesk/hubot-questionnaire-framework.git"},"author":{"name":"Alterdesk"},"bugs":{"url":"https://github.com/Alterdesk/hubot-questionnaire-framework/issues"},"license":"MIT","readme":"# Hubot Questionnaire Framework\n\nFramework for creating a questionnaire(follow up questions) isolated per user and per room for \n[Hubot](https://hubot.github.com/) scripts. It also enables listening to Alterdesk messenger events.\n\n## Example script\nThe [Alterdesk Hubot Example](https://github.com/Alterdesk/hubot-example) uses the questionnaire framework in \n[example.js](https://github.com/Alterdesk/hubot-example/blob/master/alterdesk-example-script/example.js)\n\n## Dependencies\n\nRequired\n* [Hubot](https://hubot.github.com/)\n* [node-messenger-extra](https://github.com/Alterdesk/node-messenger-extra)\n\nOptional for request messages\n* [node-messenger-sdk](https://github.com/Alterdesk/node-messenger-sdk)\n\n## Classes\n### Control\nThe control class can override the default Hubot message receiver to:\n* Manage accepted commands\n* Override the default Hubot help command\n* Adding/Removing message listeners per user per room\n* Listen for [Alterdesk messenger events](https://api.alterdesk.com/documentation/gateway) when using the \n[Hubot Alterdesk Adapter](https://github.com/Alterdesk/hubot-alterdesk-adapter)\n\n#### Minimal setup for Control\nTo intercept messages with the control instance the following code is needed\n```javascript\nconst {Control} = require('hubot-questionnaire-framework');\n\nvar control;\n\nmodule.exports = function(robot) {\n    control = new Control();\n    control.overrideReceiver(robot);\n};\n```\n\n#### Authentication events\nAuthentication events are received when the Hubot instance is authenticated on the Messenger.\n```javascript\ncontrol.setAuthenticatedCallback(function(user) {\n    console.log(\"Authenticated: \" + user.id);\n});\n```\n\n#### Typing events\nDetect when a user starts or stops typing in a chat.\n```javascript\ncontrol.setTypingCallback(function(userId, typing, chatId, isGroup) {\n    console.log(\"Typing: \" + typing + \" user: \" + userId + \" chat: \" + chatId + \" isGroup: \" + isGroup);\n});\n```\n\n#### Presence events\nDetect when a user changes its presence.\n```javascript\ncontrol.setPresenceCallback(function(userId, status) {\n    console.log(\"Presence: user: \" + userId + \" status: \" + status);\n});\n```\n\n#### New chat events\nDetect when Hubot is added to a new chat.\n```javascript\ncontrol.setNewChatCallback(function(chatId, isGroup) {\n    console.log(\"New chat: \" + chatId + \" isGroup: \" + isGroup);\n});\n```\n\n#### Removed from chat events\nDetect when Hubot is removed from a chat.\n```javascript\ncontrol.setRemovedFromChatCallback(function(groupId) {\n    console.log(\"Removed from groupchat: \" + groupId);\n});\n```\n\n#### Chat closed events\nDetect when a chat is closed.\n```javascript\ncontrol.setClosedChatCallback(function(groupId) {\n    console.log(\"Chat closed: \" + groupId);\n});\n```\n\n#### Message liked events\nDetect when a message is liked.\n```javascript\ncontrol.setMessageLikedCallback(function(userId, messageId, chatId, isGroup) {\n    console.log(\"Message liked: id: \" + messageId + \" user: \" + userId + \" chat: \" + chatId + \" isGroup: \" + isGroup);\n});\n```\n\n#### Message deleted events\nDetect when a message is deleted.\n```javascript\ncontrol.setMessageDeletedCallback(function(userId, messageId, chatId, isGroup) {\n    console.log(\"Message deleted: id: \" + messageId + \" user: \" + userId + \" chat: \" + chatId + \" isGroup: \" + isGroup);\n});\n```\n\n#### User verified event\nDetect when a user accepts or rejects a verification request(user is verified when accepted is received)\n```javascript\ncontrol.setVerificationCallback(function(userId, messageId, chatId, isGroup, accepted) {\n        console.log(\"Verification: id: \" + messageId + \" user: \" + userId + \" chat: \" + chatId + \" isGroup: \" + isGroup + \" accepted: \" + accepted);\n    });\n```\n\n#### Group member events\nDetect when users are added in or removed from a groupchat.\n```javascript\ncontrol.setGroupMemberCallback(function(groupId, added, userId, users) {\n    for(var index in users) {\n        var user = users[index];\n        if(added) {\n            console.log(\"Added in group: \" + groupId + \" userId: \" + userId + \" member: \" + user.id);\n        } else {\n            console.log(\"Removed from group: \" + groupId + \" userId: \" + userId + \" member: \" + user.id);\n        }\n    }\n});\n```\n\n#### Group subscription events\nDetect when Hubot is subscribed or unsubscribed from a groupchat.\n```javascript\ncontrol.setGroupSubscribedCallback(function(groupId, subscribed) {\n    console.log(\"Subscribed: \" + subscribed + \" chat: \" + groupId);\n});\n```\n\n#### Question answered question event\nDetect that a question has been answered during a Flow\n```javascript\ncontrol.setQuestionAnsweredCallback(function(userId, answerKey, answers) {\n    console.log(\"Question answered: \" + userId + \" key: \" + answerKey + \" value: \" + answers.get(answerKey));\n});\n```\n\n### Flow\nTo easily create a questionnaire, the Flow class can be used to create a flow of questions.\n\nFlow constructor parameters\n* Control instance\n* Text to send when the user has stopped the flow *(optional)*\n* Text to send when an error occurs in the flow *(optional)*\n\n#### Create a simple flow of questions\n\nExample of a flow for inviting a user is given below. You can chain functions like text() to add questions to the flow. \n```javascript\nrobot.hear(/start/i, function(msg) {\n    new Flow(control, \"Stopped inviting.\", \"Error occured during invite\")\n    .text(\"firstName\", \"What is the first name?\", \"Invalid name.\")\n    .text(\"lastName\", \"What is the last name?\", \"Invalid name.\")\n    .email(\"email\", \"What is the email address\", \"Invalid email.\")\n    .summary(getSummary)\n    .polar(\"confirmed\", \"Are you sure you want to send the invite?\", \"Invalid confirmation.\")\n    .positive(positiveRegex)\n    .negative(negativeRegex)\n    .timeout(600000)\n    .finish(callbackFormFinished)\n    .start(msg);\n})\n```\n\n#### Summary\n\nThe summary() function allows you to send a summary of the given answers after the last added question. The summary will\nbe generated by the function that you passed, and then sent to the user. \n\nExample of a summary function\n```javascript\nvar getSummary(answers) {\n    var summary = \"Is this correct?\";\n    summary += \"\\n\\nFirst name:\\n    \" + answers.get(\"firstName\"); \n    summary += \"\\n\\nLast name:\\n    \" + answers.get(\"lastName\"); \n    summary += \"\\n\\nEmail address:\\n    \" + answers.get(\"email\");\n    return summary; \n}\n```\n\n#### Override default timeout settings\n\nUsing the function timeout(), you can override the timeout settings of the last added question\n\n```javascript\n// Override timeout time to 5 minutes to last added question\nflow.timeout(300000);\n// Override timeout time to 5 minutes and custom timeout text to last added question\nflow.timeout(300000, \"5 minutes are up, too late\");\n// Override timeout time to 10 minutes and use custom timeout callback\nflow.timeout(600000, null, function() {\n    console.log(\"Custom timeout callback triggered\");\n});\n```\n\n#### Flow finished callback\nThe finish() function will allow you to set a callback\nthat is called when the flow is finished in which you can use the given answers to preform a task.\n\nExample of a finish callback function\n```javascript\nvar callbackFormFinished = function(response, answers) {\n    if(!answers(\"confirmed\")) {\n        response.send(\"Discarded invite\");\n        return;\n    }\n    response(\"Sending invite\");\n    // Execute invite code\n};\n```\n\n### Question\nThe Question class is extended by the question classes below, the subclasses can be added to a flow instance to ask the\nuser a question with certain rules.\n\nQuestion constructor\n* Answer key to use when storing given answer in Answers object\n* Question text to send to the user\n* Text to send when a given answer is invalid\n\nEach Question sub class has a convenience function in the Flow class, but you can manually add questions to a flow before \nthe flow is started like this\n```javascript\n// Manually add a question to the flow\nflow.add(new TextQuestion(\"myKey\", \"Can you send me some text?\", \"Invalid text.\"));\n```\n\n#### Format a given answer\nWhen a user has given a valid answer, the answer may need need formatting, this can be done with a format callback.\n```javascript\nform.text(\"formatted\", \"\", \"Invalid answer.\")\n.formatAnswer(formatAnswerFunction);\n```\n\nFormat answer text callback function example\n```javascript\nvar formatAnswerFunction = function(value) {\n    return value.toLowerCase();\n};\n```\n\n#### Format a question by given answers\nTo format a question by using answers given earlier in the flow, a format callback can be set, if the format callback\nfails, the unformatted text will be used as fallback.\n\nAdd a format callback to a question\n```javascript\nform.text(\"textAnswer\", \"Fallback question text?\", \"Invalid answer.\")\n.formatQuestion(formatTextQuestion);\n```\n\nFormat question text callback function example\n```javascript\nvar formatTextQuestion = function(answers) {\n    var givenAnswer = answers.get(\"given_answer_key\");\n    if(givenAnswer != null) {\n        // Has a value to format the question with\n        return \"Formatted question with \" + givenAnswer + \"?\";\n    }\n    // Unable to format question, use fallback text\n    return null;\n};\n```\n\n#### Ask a question to multiple users\nYou can ask a question to multiple users in a flow, by using the results of a MentionQuestion or a given list of user \nids. The flow continues after each user has answered the question or the break value was given.\n\nAsk a question to mentioned users\n```javascript\n// Regular expressions to use to parse positive and negative answers with\nvar positiveRegex = new RegExp(/yes/, 'i');\nvar negativeRegex = new RegExp(/no/, 'i');\n\n// Break waiting for other user answers when a user rejected the question\nvar breakOn = false;\n// Continue the flow when rejected\nvar stopFlowOnBreak = false;\n\n// Ask a MentionQuestion, store results with the key \"mentioned\" and use with askMentions() to \n// create a multi user question\nflow.mention(\"mentioned\", \"Who should accept (Mention the users with '@')?\", \"Invalid mention\")\n.polar(\"accepted\", \"Do you all accept?\", \"Invalid answer\")\n.positive(positiveRegex)\n.negative(negativeRegex)\n.askMentions(\"mentioned\")\n.breakOnValue(breakOn, stopFlowOnBreak)\n.multiUserSummary(acceptSummary);\n```\n\nAsk a question to a list of user ids\n```javascript\n// List of user ids to ask the question to\nvar userIds = [\"<USER_ID_1>\", \"<USER_ID_2>\", \"<USER_ID_3>\"];\n\n// Ask each user to add a note, functions like breakOnValue() and multiUserSummary() can also be used here \nflow.text(\"note\",\"Add a note?\",\"Invalid note\")\n.askUserIds(userIds);\n```\n\nOptional multi user answer summary callback\n```javascript\nvar acceptSummary = funtion(answers, currentUserId, breaking) {\n    var summary = \"\";\n    // Retrieve the answers object for the multi user question, the value is stored with the user id as the key\n    var acceptedAnswers = answers.get(\"accepted\");\n    // Retrieve the currently given answer\n    summary += \"User \" + currentUserId + \" answered \" + acceptedAnswers.get(currentUserId);\n    // Check if the break value was given\n    if(breaking) {\n        return summary;\n    }\n    // Retrieve the user mentions that should answer this question\n    var mentioned = answers.get(\"mentioned\");\n    for(var index in mentioned) {\n        var mention = mentioned[index];\n        var mentionUserId = mention[\"id\"];\n        // Check if an answer value is set for the user id\n        if(acceptedAnswers.get(mentionUserId) == null) {\n            summary += \"User \" + mentionUserId + \" has not answered the question yet\";\n        }\n    }\n    return summary;\n}\n```\n\nOptional break multi user question on value\n```javascript\n// Stop waiting on the remaining users when a user answers a polar question negatively\nvar breakOn = false;\nvar stopFlowOnBreak = false;\nflow.breakOnValue(breakOn, stopFlowOnBreak);\n```\n\nOptional break multi user question on regular expression\n```javascript\n// Stop waiting on the remaining users when a user sends \"breaktext\" or \"decline\"\nvar breakRegex = new RegExp(/breaktext|decline/, 'i');\nvar stopFlowOnBreak = false;\nflow.breakOnRegex(breakRegex, stopFlowOnBreak);\n```\n\nOptional break multi user question on answer count\n```javascript\n// Stop waiting on the remaining users when two answers are received\nflow.breakOnCount(2);\n```\n\n### TextQuestion\nTo add a question that excepts non-empty text, simply call text() on a flow instance before starting the flow.\n```javascript\n// Ask user to send some text and store in Answers with the key \"myKey\"\nflow.text(\"myKey\", \"Can you send me some text?\", \"Invalid text.\");\n\n// Ask for text with the length between 4 and 32\nflow.text(\"limitedText\", \"Can you send me some text between 4 and 32 characters long?\", \"Invalid text or length.\")\n.length(4, 32);\n\n// Ask for text that matches a specific regex\nflow.text(\"regexText\", \"Can you send me apples, pineapple or banana?\", \"Invalid text or does not match regex.\")\n.regex(new RegExp(/apples|pineapple|banana/, 'i'));\n```\n\n### NumberQuestion\nAdding a question that only accepts numbers, the NumberQuestion can be used. You can optionally use a range of accepted \nvalues. Adding a NumberQuestion can be done with the convenience function number().\n```javascript\n// Ask the user for a number and store with key \"number\"\nflow.number(\"number\", \"Can you send me a number?\", \"Invalid number.\");\n\n// Ask a number between 2 and 5\nflow.number(\"limitedNumber\", \"Can you send me a number between 2 and 5?\", \"Invalid number or outside range\")\n.range(2, 5);\n```\n\n### EmailQuestion\nThe EmailQuestion class is used to ask a user for an email address, you can optionally limit the accepted answers by \ndomain by passing an array of accepted domains. Add an EmailQuestion by calling email() on the flow instance.\n```javascript\n// Ask for any email address\nflow.email(\"email\", \"What is your email address?\", \"Invalid email\")\n\n// Only accept domains \"alterdesk.com\" and \".nl\"\nflow.email(\"limitedEmail\", \"What is your email address?\", \"Invalid email or domain not allowed\")\n.domains([\"alterdesk.com\", \".nl\"]);\n```\n\n### PhoneNumberQuestion\nAks the user for a phone number by using the PhoneNumberQuestion, which can be configured to only accept given country \ncodes by passing an array of accepted codes. Add a phone number question by using number().\n```javascript\n// Ask for any phone number\nflow.number(\"phone\", \"What is your phone number?\", \"Invalid phone number\");\n\n// Only accept Dutch phone numbers\nflow.number(\"dutch\", \"What is your phone number?\", \"Not a Dutch phone number\")\n.countryCodes([\"+31\"]);\n```\n\n### MentionQuestion\nYou can ask a user to tag chat members in a flow, the user can use '@' to start a mention tag in the messenger. Ask a\nMentionQuestion by using mention().\n```javascript\n// Ask user to mention chat members\nflow.mention(\"tagged\", \"Which users do you want to include? (Use '@' to mention users)\", \"Invalid mention.\");\n\n// Do not allow \"All members\" and robot mentions\nflow.mention(\"limitedTag\", \"Which users do you want to include? (Use '@' to mention users)\", \"Invalid mention.\")\n.allAllowed(false)\n.robotAllowed(false)\n.completeMentions(false);\n\n// Always include these mentions after user gives a valid answer\nvar mention = {};\nmention[\"id\"] = \"<USER_UUID>\";\nmention[\"first_name\"] = \"First\";\nmention[\"last_name\"] = \"Last\";\nmention[\"company_name\"] = \"Company\";\nvar mentions = [];\nmentions.push(mention);\nflow.mention(\"taggedIncluded\", \"Which users do you want to include? (Use '@' to mention users)\", \"Invalid mention.\")\n.includeMentions(mentions);\n```\n\n### AttachmentQuestion\nWhen using the messenger, you can ask the user to send one or more attachments with a message.\n```javascript\n// Ask for an attachment\nflow.attachment(\"attachments\", \"Can you send me a file to use?\", \"Invalid attachment\");\n\n// Ask for one to three attachments from 1KB to 1MB\nflow.attachment(\"files\", \"Can you send me one to three attachments? (1KB-1MB)\", \"Invalid attachment or outside ranges\")\n.count(1, 3)\n.size(1024, 1048576);\n```\n\n### PolarQuestion\nTo let the user make a decision by answering either positively or negatively to a question, the PolarQuestion can be \nused. This allows for \"Yes/No\" questions and optionally start a sub flow of questions for an answer.\nTo add a polar question, you can use the convenience function polar() with the following parameters\n* Answer key to use when storing boolean(positive/negative) in Answers object\n* Question text to ask\n* Invalid answer text\n* Positive answer regex\n* Negative answer regex\n* Sub flow to start when a positive answer was given *(optional)*\n* Sub flow to start when a negative answer was given *(optional)*\n* Button to trigger positive answer *(optional)*\n* Button to trigger negative answer *(optional)*\n\n```javascript\n// Regular expressions to use to parse positive and negative answers with\nvar positiveRegex = new RegExp(/yes/, 'i');\nvar negativeRegex = new RegExp(/no/, 'i');\n\nvar positiveFlow = new Flow(control);\npositiveFlow.email(\"email\", \"What is your email address?\", \"Invalid email address\");\n\nvar negativeFlow = new Flow(control);\nnegativeFlow.text(\"reason\", \"That is to bad, can you give us a reason?\", \"Invalid answer\");\n\nflow.polar(\"startedSubFlow\", \"Do you want to subscribe to our newsletter? (Yes or no)\", \"Invalid answer.\")\n.positive(positiveRegex, positiveFlow)\n.positiveButton(\"yes\", \"Yes\", \"green\")\n.negative(negativeRegex, negativeFlow)\n.negativeButton(\"no\", \"No\", \"red\");\n```\n\n### MultipleChoiceQuestion\nTo let the user make a choice of multiple options, the MultipleChoiceQuestion can be used. Each option is set with a \ncorresponding regex and an optional sub flow. First call multiple() on the flow and for each option call option() after \nthat. Optionally you can call button() to add a request message button to each option, depends on messenger Api instance\n```javascript\n// Regular expressions to use to parse options with\nvar emailRegex = new RegExp(/email/, 'i');\nvar phoneRegex = new RegExp(/phone/, 'i');\nvar skipRegex = new RegExp(/skip/, 'i');\n\nflow.multiple(\"registerBy\", \"Do you want to register by email, phone number or skip this question?\", \"Invalid choice.\")\n.option(emailRegex, emailFlow)\n.button(\"email\", \"E-mail\", \"blue\")\n.option(phoneRegex, phoneFlow)\n.button(\"phone\", \"Phone number\", \"blue\")\n.option(skipRegex)\n.button(\"skip\", \"Skip\", \"red\");\n```\n\n### VerificationQuestion\nAsk the user to verify his/her account with the given identity provider, user can accept the request and login on the \nidentity provider or reject the request.\n```javascript\nflow.verification(\"userVerified\", \"idin\")\n.verified(verifiedFlow)\n.unverified(verifiedFlow);\n```\n\n### Answers\nData container class can hold data that is collected in a questionnaire\nAn Answer instance is passed along by a Listener, \nso each Listener callback can use or modify the data for the questionnaire.\n\nFor example\n* Answers given by the user\n* Start date of the current questionnaire\n* File path\n* URL\n* Other data containers\n\n#### Add an answer\nYou can add an answer value by key\n```javascript\nvar answers = new Answers();\nanswers.add(\"myKey\", myValue);\n```\n\n#### Remove an answer\nRemove an answer by key, the remove function returns the value\n```javascript\nvar removedValue = answers.remove(\"myKey\");\n```\n\n#### Get an answer\nTo get an answer, you can retrieve the answer value by key\n```javascript\nvar myValue = answers.get(\"myKey\");\n```\n\n#### Get used keys\nGet an array of keys of answers that are given\n```javascript\nvar keys = answers.keys();\nfor(let i in keys) {\n    var key = keys[i];\n    var value = answers.get(key);\n}\n```\n\n#### Answer collection size\nGet the size of the collection of answers\n```javascript\nvar size = answers.size();\n```\n\n## Other\n\n### Environment variables\nCertain settings can also be set through environment variables if desired\n\n#### Variables\nQuestionnaire log level\n* HUBOT_QUESTIONNAIRE_LOG_LEVEL *(String)*\n\nResponse timeout milliseconds\n* HUBOT_QUESTIONNAIRE_RESPONSE_TIMEOUT *(Integer)*\n\nResponse timeout text to send on timeout\n* HUBOT_QUESTIONNAIRE_RESPONSE_TIMEOUT_TEXT *(String)*\n\nNeed to mention robot in group to trigger command\n* HUBOT_QUESTIONNAIRE_NEED_MENTION_IN_GROUP *(Boolean)*\n\nCatch commands that are not present in the accepted commands list\n* HUBOT_QUESTIONNAIRE_CATCH_ALL *(Boolean)*\n\nCatch all text to send on unaccepted command\n* HUBOT_QUESTIONNAIRE_CATCH_ALL_TEXT *(String)*\n\nCatch all button name to use on unaccepted command, depends on messenger Api instance\n* HUBOT_QUESTIONNAIRE_CATCH_ALL_BUTTON_NAME *(String)*\n\nCatch all button label to use on unaccepted command, depends on messenger Api instance\n* HUBOT_QUESTIONNAIRE_CATCH_ALL_BUTTON_LABEL *(String)*\n\nCatch all button style to use on unaccepted command, depends on messenger Api instance\n* HUBOT_QUESTIONNAIRE_CATCH_ALL_BUTTON_STYLE *(String)*\n\nOverride default hubot help command\n* HUBOT_QUESTIONNAIRE_CATCH_HELP *(Boolean)*\n\nHelp text to send when default hubot help command is overridden\n* HUBOT_QUESTIONNAIRE_CATCH_HELP_TEXT *(String)*\n\nRemove a questionnaire listener and pending request when a user leave is detected\n* HUBOT_QUESTIONNAIRE_REMOVE_ON_LEAVE *(Boolean)*\n\n#### Set an environment variable\nYou can set an environment variable in your hubot startup script like this\n```sh\n#!/bin/sh\n\nset -e\n\nexport HUBOT_QUESTIONNAIRE_RESPONSE_TIMEOUT=60000\n\nexec node_modules/.bin/hubot --name \"hubot\" \"$@\"\n```\n\n## Reference\n\n### Answers\n#### constructor()\n\nCreate a new Answers instance\n\n#### add(key, value)\n\nAdd a value by key\n* key *(String)* - Key to add the value with\n* value *(Object)* - Value to add\n\n#### get(key)\n\nGet a value by key\n* key *(String)* - Key that the requested value was added with\n\nreturns *(Object)* - Value corresponding to the key\n\n#### remove(key)\n\nRemove a value by key\n* key *(String)* - Key that the requested value was added with\n\nreturns *(Object)* - Removed value that corresponds to the key\n\n#### keys()\n\nGet the keys that are added\n\nreturns *(Array)* - Array of keys\n\n#### size()\n\nCount of values that are added\n\nreturns *(Integer)* - Size of added values\n\n\n### Control\n#### constructor()\n\nCreate a new Control instance\n\n#### setMessengerApi(messengerApi)\n\nSet the optional Api instance from node-messenger-sdk for support for request and verification messages\n* messengerApi *(Api)* - Api instance\n\n#### overrideReceiver(robot)\n\nOverride the default Hubot receiver with the questionnaire receiver\n* robot *(Robot)* - Hubot Robot instance to override the receiver for\n\n#### getUserId(user)\n\nReturn the user id for a user, use with Alterdesk groupchats\n* user *(User)* - Hubot User to get the id for\n\nreturns *(String)* - User id\n\n#### isUserInGroup(user)\n\nCheck if a user is talking to Hubot from a groupchat\n* user *(User)* - Hubot User to check for\n\nreturns *(Boolean)* - If the user is talking from a groupchat\n\n#### setStopRegex(regexp)\n\nSet the regular expression to stop flows on\n* regexp *(RegExp)* - Regular Expression to stop flows with\n\n#### setFlowStopText(text)\n\nSet the message text to send when a Flow is stopped with the stop command\n* text *(String)* - Text to send on Flow stop\n\n#### setBackRegex(regexp)\n\nSet the regular expression to go back in a flow with\n* regexp *(RegExp)* - Regular Expression to go back in flow with\n\n#### setFlowBackText(text)\n\nSet the message text to send when going back a question with the back command\n* text *(String)* - Text to send on back command\n\n#### setFlowErrorText(text)\n\nSet the message text to send when a flow stops with an error\n* text *(String)* - Text to send on Flow error\n\n#### setHelpRegex(regexp)\n\nSet the regular expression to trigger the help message with\n* regexp *(RegExp)* - Regular Expression to trigger the help message with\n\n#### setResponseTimeoutText(text)\n\nSet the text to send when a user does not respond within the configured time\n* text *(String)* - Text to send on response timeout\n\n#### setResponseTimeoutMs(ms)\n\nSet the milliseconds to wait for a user response\n* ms *(Integer)* - Milliseconds to wait for response\n\n#### setCatchAll(catch)\n\nSet if unknown commands should be catched\n* catch *(Boolean)* - If unknown commands should be catched by the overridden receiver\n\n#### setCatchAllText(text)\n\nSet the text to send when an unknown command is catched\n* text *(String)* - Text to send when an unknown command is catched\n\n#### setCatchAllButton(name, label, style)\n\nAdd a button to the catch all message\n* name *(String)* - Name of the button, text received when button is pressed\n* label *(String)* - Label on the button\n* style *(String)* - Optional style of the button (defaults to 'theme')\n\n#### setCatchHelp(catch)\n\nSet if the default Hubot help should be overridden\n* catch *(Boolean)* - If the Hubot help should be overridden\n\n#### setCatchHelpText(text)\n\nSet the text to send when the help command is triggered\n* text *(String)* - Text to send when help command is triggered\n\n#### setHelpQuestionStyle(style)\n\nSet the style of request message to use when buttons are added to the help message\n* style *(String)* - Request message style\n\n#### createHubotResponse(userId, chatId, isGroup)\n\nCreate a Hubot Response object for a given user and chat\n* userId *(String)* - Alterdesk user id\n* chatId *(String)* - Alterdesk chat id\n* isGroup *(Boolean)* - If the chat is a groupchat or one-to-one chat\n\n#### setAuthenticatedCallback(callback)\n\nSet the callback to call when Hubot is authenticated on Alterdesk, callback is called with the user data\n* callback *(Function(user))* - Function callback called when authenticated\n  * user *(User)* - Alterdek user data\n\n#### setTypingCallback(callback) \n\nSet the callback to call when a user is typing on Alterdesk, callback is called with the user id and a boolean if the user is typing\n* callback *(Function(userId, typing))* - Function callback called when a user starts or stops typing\n  * userId *(String)* - Alterdesk user id \n  * typing *(Boolean)* - If the user is typing\n\n#### setPresenceCallback(callback)\n\nCallback that is called when a user presence is detected\n* callback *(Function(userId, status))* - Function callback called with Alterdesk user id and the status string\n\n#### setNewChatCallback(callback)\n\nCallback that is called when a new chat is detected\n* callback *(Function(chatId, isGroup))* - Function callback called when a new chat is created/added\n  * chatId *(String)* - Alterdesk chat id\n  * isGroup *(Boolean)* - If the chat is a groupchat or one-to-one chat\n\n#### setRemovedFromChatCallback(callback)\n\nCallback that is called when remove from chat is detected\n* callback *(Function(groupId))* - Function callback called with the Alterdesk group chat id that the Hubot is removed from\n\n#### setClosedChatCallback(callback)\n\nCallback that is called when a chat close is detected\n* callback *(Function(groupId))* - Function callback called when a groupchat is closed\n  * groupId *(String)* - Alterdesk group chat id\n\n#### setMessageLikedCallback(callback)\n\nCallback that is called when a message is liked\n* callback *(Function(userId, messageId, chatId, isGroup))* - Function callback when a message is liked\n  * userId *(String)* - Alterdesk user id\n  * messageId *(String)* - Alterdesk message id\n  * chatId *(String)* - Alterdesk chat id\n  * isGroup *(Boolean)* - If the chat is a groupchat or one-to-one chat\n\n#### setMessageDeletedCallback(callback)\n\nCallback that is called when a message is deleted\n* callback *(Function(userId, messageId, chatId, isGroup))* - Function callback when a message is deleted\n  * userId *(String)* - Alterdesk user id\n  * messageId *(String)* - Alterdesk message id\n  * chatId *(String)* - Alterdesk chat id\n  * isGroup *(Boolean)* - If the chat is a groupchat or one-to-one chat\n\n\n#### setVerificationCallback(callback)\n\nDetect when a user accepts or rejects a verification request(user is verified when accepted is received)\n* callback *(Function(userId, messageId, chatId, isGroup, accepted))* - Function callback when a verification is answered\n  * userId *(String)* - Alterdesk user id\n  * messageId *(String)* - Alterdesk message id\n  * chatId *(String)* - Alterdesk chat id\n  * isGroup *(Boolean)* - If the chat is a groupchat or one-to-one chat\n  * accepted *(Boolean)* - If the verification request was accepted or rejected\n\n#### setQuestionCallback(callback)\n\nDetect when user answers a question request message(deprecated, use setQuestionAnsweredCallback)\n* callback *(Function(userId, messageId, chatId, isGroup, options))* - Function callback when a request is answered\n  * userId *(String)* - Alterdesk user id\n  * messageId *(String)* - Alterdesk message id\n  * chatId *(String)* - Alterdesk chat id\n  * isGroup *(Boolean)* - If the chat is a groupchat or one-to-one chat\n  * options *(Array)* - Array of chosen options\n\n#### setGroupMemberCallback(callback)\n\nCallback that is called when a group member is added or removed\n* callback *(Function(groupId, added, userId, users))* - Function callback called when a groupchat member is added or removed\n  * groupId *(String)* - Alterdesk group chat id\n  * added *(Boolean)* - If the member is added or removed\n  * userId *(String)* - Alterdesk user id that added or removed the members\n  * users *(Array)* - Array of Alterdesk user data of the members\n\n#### setGroupSubscribedCallback(callback)\n\nCallback that is called when subscribed/unsubscribed to/from a groupchat\n* callback *(Function(groupId, subscribed))* - Function callback called when Hubot is subscribed/unsubscribed to/from a groupchat \n  * groupId *(String)* - Alterdesk group chat id\n  * subscribed *(Boolean)* - If hubot is subscribed or unsubscribed\n\n#### setUserAnsweredCallback(callback)\n\nDetect that a user has answered a question during a Flow(deprecated, use setQuestionAnsweredCallback)\n* callback *(Function(userId, answerKey, answerValue))* - Function callback when a user answers a question during a flow\n  * userId *(String)* - Alterdesk user id\n  * answerKey *(String)* - Answer key that is answered\n  * answerValue *(String)* - Answer value\n\n#### setQuestionAnsweredCallback(callback)\n\nCallback for when a question in a flow has been answered\n* callback *(Function(userId, answerKey, answers))* - Function callback when a question is answered during a flow\n  * userId *(String)* - Alterdesk user id\n  * answerKey *(String)* - Answer key that is answered\n  * answers *(Answers)* - Answers instance\n\n#### setRemoveListenerOnLeave(remove)  \n\nSet if a Listener should be removed when a LeaveMessage for the user is received\n* remove *(Boolean)* - If the Listener should be removed\n\n#### addAcceptedCommand(command, helpText, buttonLabel, buttonStyle) \n\nAdd an accepted command\n* command *(String)* - Command text to listen for\n* helpText *(String)* - Help text to show when the help command is triggered\n* buttonLabel *(String)* - Optional button label for this command in help message, depends on messenger Api instance\n* buttonLabel *(String)* - Optional button style for this command in help message, depends on messenger Api instance\n\n### Flow\n#### constructor(control, stopText, errorText, backText)\n\nCreate a new Flow instance\n* control *(Control)* - Control instance to use\n* stopText *(String)* - Optional override message text to send when the flow is stopped\n* errorText *(String)* - Optional override message text to send when the flow stops with an error\n* backText *(String)* - Optional override message text to send when going back a question\n\n#### add(question)\n\nAdd Question to the Flow\n* question *(Question)* - Question to add to the Flow\n\nreturns *(Flow)* - Flow instance\n\n#### info(text, waitMs)\n\nAdd a information message to the flow\n* text *(String)* - Information message text to send\n* waitMs *(Integer)* - Milliseconds to wait after sending information\n\nreturns *(Flow)* - Flow instance\n\n#### action(callback, waitMs)\n\nAdd an external asynchronous action to the flow\n* callback *(Function(response, answers, flowCallback))* - Function callback called when the external action should be triggered\n  * response *(Response)* - Hubot Response instance\n  * answers *(Answers)* - Answers instance\n  * flowCallback *(Function())* - Callback to call when the flow should continue\n* waitMs *(Integer)* - Milliseconds to wait after executing action\n\n#### text(answerKey, questionText, invalidText)\n\nAdd a TextQuestion to the Flow\n* answerKey *(String)* - Key to store answer in Answers instance with\n* questionText *(String)* - Text to send when the question is triggered\n* invalidText *(String)* - Text to send when the user sends an invalid answer\n\nreturns *(Flow)* - Flow instance\n\n#### regex(regex)\n\nOverride the regex used in the last added TextQuestion\n* regex *(RegExp)* - Regular expression to check answer with\n\nreturns *(Flow)* - Flow instance\n\n#### length(minLength, maxLength)\n\nSet the minimal and/or maximum accepted length of the last added TextQuestion\n* minLength *(Integer)* - Minimum accepted length\n* maxLength *(Integer)* - Maximum accepted length\n\nreturns *(Flow)* - Flow instance\n\n#### capitalize()\n\nCapitalize the first letter of the answer of the last added TextQuestion\n\nreturns *(Flow)* - Flow instance\n\n#### lastName()\n\nCapitalize the answer as a last name of the last added TextQuestion\n\nreturns *(Flow)* - Flow instance\n\n#### number(answerKey, questionText, invalidText)\n\nAdd a NumberQuestion to the Flow\n* answerKey *(String)* - Key to store answer in Answers instance with\n* questionText *(String)* - Text to send when the question is triggered\n* invalidText *(String)* - Text to send when the user sends an invalid answer\n\nreturns *(Flow)* - Flow instance\n\n#### range(minValue, maxValue)\n\nSet the minimum and/or maximum value range of the last added NumberQuestion\n* minValue *(Integer)* - Minimum accepted value\n* maxValue *(Integer)* - Maximum accepted value\n\nreturns *(Flow)* - Flow instance\n\n#### email(answerKey, questionText, invalidText)\n\nAdd an EmailQuestion to the Flow\n* answerKey *(String)* - Key to store answer in Answers instance with\n* questionText *(String)* - Text to send when the question is triggered\n* invalidText *(String)* - Text to send when the user sends an invalid answer\n\nreturns *(Flow)* - Flow instance\n\n#### domains(allowedDomains)\n\nSet the allowed email domains of the last added EmailQuestion\n* allowedDomains *(Array)* - String array of accepted domains\n\nreturns *(Flow)* - Flow instance\n\n#### phone(answerKey, questionText, invalidText)\n\nAdd a PhoneNumberQuestion to the Flow\n* answerKey *(String)* - Key to store answer in Answers instance with\n* questionText *(String)* - Text to send when the question is triggered\n* invalidText *(String)* - Text to send when the user sends an invalid answer\n\nreturns *(Flow)* - Flow instance\n\n#### countryCodes(allowedCountryCodes)\n\nSet the allowed country codes of the last added PhoneNumberQuestion\n* allowedCountryCodes *(Array)* - String array of allowed country codes\n\nreturns *(Flow)* - Flow instance\n\n#### mention(answerKey, questionText, invalidText)\n\nAdd a MentionQuestion to the Flow\n* answerKey *(String)* - Key to store answer in Answers instance with\n* questionText *(String)* - Text to send when the question is triggered\n* invalidText *(String)* - Text to send when the user sends an invalid answer\n\nreturns *(Flow)* - Flow instance\n\n#### includeMentions(mentions)\n\nAdd mentions to include after answer of the last added MentionQuestion\n* mentions *(Array)* - Alterdesk mention user data array to add\n\nreturns *(Flow)* - Flow instance\n\n#### allAllowed(allowed)\n\nChange if the all mentioned tag is allowed of the last added MentionQuestion\n* allowed *(Boolean)* - If the mention all tag is allowed\n\nreturns *(Flow)* - Flow instance\n\n#### robotAllowed(allowed)\n\nChange if the robot mentioned tag is allowed of the last added MentionQuestion\n* allowed *(allowed)* - If tagging the Hubot user id is allowed\n\nreturns *(Flow)* - Flow instance\n\n#### completeMentions(onlyCompleteAll)\n\nFill in all user data for the last added MentionQuestion, depends on messenger Api instance\n* onlyCompleteAll *(Boolean)* - Only retrieve user data when all mention is used\n\n#### attachment(answerKey, questionText, invalidText)\n\nAdd an AttachmentQuestion to the Flow\n* answerKey *(String)* - Key to store answer in Answers instance with\n* questionText *(String)* - Text to send when the question is triggered\n* invalidText *(String)* - Text to send when the user sends an invalid answer\n\nreturns *(Flow)* - Flow instance\n\n#### count(minCount, maxCount)\n\nSet the minimum and/or maximum count of attachments of the last added AttachmentQuestion\n* minCount *(Integer)* - Minimum count of attachments\n* maxCount *(Integer)* - Maximum count of attachments\n\nreturns *(Flow)* - Flow instance\n\n#### size(minSize, maxSize)\n\nSet the minimum and/or maximum file size in bytes of attachments of the last added AttachmentQuestion\n* minSize *(Integer)* - Minimum file size in bytes\n* maxSize *(Integer)* - Maximum file size in bytes\n\nreturns *(Flow)* - Flow instance\n\n#### extensions(allowedExtensions)\n\nSet the allowed file extensions of the last added AttachmentQuestion\n* allowedExtensions *(Array)* - String array of allowed extensions\n\nreturns *(Flow)* - Flow instance\n\n#### polar(answerKey, questionText, invalidText)\n\nAdd a PolarQuestion to the Flow\n* answerKey *(String)* - Key to store answer in Answers instance with\n* questionText *(String)* - Text to send when the question is triggered\n* invalidText *(String)* - Text to send when the user sends an invalid answer\n\nreturns *(Flow)* - Flow instance\n\n#### positive(regex, subFlow)\n\nSet the positive regex and optional sub flow of the last added PolarQuestion\n* regex *(RegExp)* - Regular expression to trigger positive answer\n* subFlow *(Flow)* - Flow to start when positive answer was given\n\nreturns *(Flow)* - Flow instance\n\n#### positiveButton(name, label, style)\n\nAdd a button to the question message for a positive answer, depends on messenger Api instance\n* name *(String)* - Name of the button, needs to trigger positive regex to function\n* label *(String)* - Label on the button\n* style *(String)* - Optional style of the button (defaults to 'green')\n\nreturns *(Flow)* - Flow instance\n\n#### negative(regex, subFlow)\n\nSet the negative regex and optional sub flow of the last added PolarQuestion\n* regex *(RegExp)* - Regular expression to trigger negative answer\n* subFlow *(Flow)* - Flow to start when negative answer was given\n\nreturns *(Flow)* - Flow instance\n\n#### negativeButton(name, label, style)\n\nAdd a button to the question message for a negative answer, depends on messenger Api instance\n* name *(String)* - Name of the button, needs to trigger negative regex to function\n* label *(String)* - Label on the button\n* style *(String)* - Optional style of the button (defaults to 'green')\n\nreturns *(Flow)* - Flow instance\n\n#### multiple(answerKey, questionText, invalidText)\n\nAdd a MultipleChoiceQuestion to the Flow\n* answerKey *(String)* - Key to store answer in Answers instance with\n* questionText *(String)* - Text to send when the question is triggered\n* invalidText *(String)* - Text to send when the user sends an invalid answer\n\nreturns *(Flow)* - Flow instance\n\n#### option(regex, subFlow, value)\n\nAdd an option regex, optional sub flow and optional value of the last added MultipleChoiceQuestion\n* regex *(RegExp)* - Regular expression to trigger option answer\n* subFlow *(Flow)* - Flow to start when option answer was given\n* value *(Object)* - Value to set as answer when option answer was given\n\nreturns *(Flow)* - Flow instance\n\n#### button(name, label, style)\n\nAdd a button to the question message for the last added option, depends on messenger Api instance\n* name *(String)* - Name of the button, needs to trigger option regex to function\n* label *(String)* - Label on the button\n* style *(String)* - Optional style of the button (defaults to 'theme')\n\nreturns *(Flow)* - Flow instance\n\n#### multiAnswer()\n\nSet the last added MultipleChoiceQuestion to allow answering with multiple options, depends on messenger Api instance\n\nreturns *(Flow)* - Flow instance\n\n#### questionStyle(style)\n\nSet the question payload style for the last added MultipleChoiceQuestion, depends on messenger Api instance\n* style *(String)* - Request message question style\n\nreturns *(Flow)* - Flow instance\n\n#### verification(answerKey, provider, retrieveAttributes)\n\nAdd a VerificationQuestion to the Flow, depends on messenger Api instance. When *retrieveAttributes* is set, the \nverification attributes are stored in the Answers object with the key \"*answerKey*_attributes\". \n* answerKey *(String)* - Key to store answer in Answers instance with\n* provider *(String)* - Identity provider to use for verification\n* retrieveAttributes *(Boolean)* - Retrieve verification attributes when successful\n\nreturns *(Flow)* - Flow instance\n\n#### verified(subFlow)\n\nSet an optional sub flow if the user is verified to the last added VerificationQuestion\n* subFlow *(Flow)* - Flow to start when the user is verified\n\nreturns *(Flow)* - Flow instance\n\n#### unverified(subFlow)\n\nSet an optional sub flow if the user declines verification to the last added VerificationQuestion\n* subFlow *(Flow)* - Flow to start when the user declines verification\n\nreturns *(Flow)* - Flow instance\n\n#### askMentions(mentionAnswerKey)\n\nAsk the last added question to the users that were mentioned a MentionQuestion earlier\n* mentionAnswerKey *(String)* - Key used to store the mentions with in Answers\n\nreturns *(Flow)* - Flow instance\n\n#### askUserIds(userIds)\n\nAsk the last added question to a list of user ids\n* userIds *(Array)* - String array of Alterdesk user ids\n\nreturns *(Flow)* - Flow instance\n\n#### breakOnValue(value, stop)\n\nBreak multi user question on a certain answer value, and set if the flow should continue or stop\n* value *(Object)* - Value to break on\n* stop *(Boolean)* - Stop flow when breaking\n\nreturns *(Flow)* - Flow instance\n\n#### breakOnRegex(regex, stop)\n\nBreak multi user question when an answer matches the given regex, and set if the flow should continue or stop\n* regex *(RegExp)* - Regular expression to break with\n* stop *(Boolean)* - Stop flow when breaking\n\nreturns *(Flow)* - Flow instance\n\n#### breakOnCount(count)\n\nBreak multi user question on a certain number of answers\n* count *(Integer)* - Count of answers to break on\n\nreturns *(Flow)* - Flow instance\n\n#### formatAnswer(callback)\n\nSet a callback to format the question text with by the answers given earlier\n* callback *(Function(answerValue))* - Callback that is called when an answer is given\n  * answerValue *(Object)* - Value of the answer\n  \n  returns *(Object)* - Formatted answer\n  \nreturns *(Flow)* - Flow instance\n\n#### formatQuestion(callback)\n\nSet a callback to format the question text with by the answers given earlier\n* callback *(Function(answers))* - Callback that is called before the question is asked\n  * answers *(Answers)* - Answers instance\n  \n  returns *(String)* - Formatted question text to send\n\nreturns *(Flow)* - Flow instance\n\n#### multiUserSummary(callback)\n\nSet a callback to summarize given answers after every user answer for a multi user question\n* callback *(Function(answers, userId, breaking))* - Callback that is called when a user answers the question\n  * answers *(Answers)* - Answers instance\n  * userId *(String)* - Alterdesk user id of the user that answered\n  * breaking *(Boolean)* - If breaking multi user question because of this answer\n\n  returns *(String)* - Summary text to send\n\nreturns *(Flow)* - Flow instance\n\n#### summary(callback, waitMs)\n\nSet an action using a callback to summarize the given answers\n* callback *(Function(answers))* - Callback called when a summary of the given answers is requested\n  * answers *(Answers)* - Answers instance\n* waitMs *(Integer)* - Milliseconds to wait after sending summary\n\n  returns *(String)* - Summary text to send\n\nreturns *(Flow)* - Flow instance\n\n#### delay(ms)\n\nUse a delay before executing the last added question\n* ms *(Integer)* - Milliseconds to delay question\n\nreturns *(Flow)* - Flow instance\n\n#### timeout(ms, text, callback)\n\nUse non-default timeout for last added question\n* ms *(Integer)* - Milliseconds to wait for response\n* text *(String)* - Optional override timeout text to send\n* callback *(Function())* - Optional override timeout callback to call\n\nreturns *(Flow)* - Flow instance\n\n#### restartButton(name, label, style)\n\nSet a restart button for error, stop and timeout messages, depends on messenger Api instance\n* name *(String)* - Name of the button, needs to trigger flow start regex to function\n* label *(String)* - Label on the button\n* style *(String)* - Optional style of the button (defaults to 'theme')\n\n#### finish(callback)\n\nSet the flow finished callback function\n* callback *(Function(response, answers))* - Callback called when the flow is finished\n  * response *(Response)* - Hubot Response instance\n  * answers *(Answers)* - Answers instance\n\nreturns *(Flow)* - Flow instance\n\n#### start(message, answers)\n\nStart the flow\n* message *(Message)* - Hubot Message instance\n* answers *(Answers)* - Answers instance\n\n\n### Information\n#### constructor(text, waitMs)\n\nCreate a new Information instance\n* text *(String)* - Information message text to send\n* waitMs *(Integer)* - Milliseconds to wait after sending information\n\n#### execute(flow, response)\n\nExecute this information message\n* flow *(Flow)* - Flow instance that the information is executed for\n* response *(Response)* - Hubot Response instance\n\n### Question\n#### constructor(answerKey, questionText, invalidText)\n\nCreate a new Question instance\n* answerKey *(String)* - Key to store answer in Answers instance with\n* questionText *(String)* - Text to send when the question is triggered\n* invalidText *(String)* - Text to send when the user sends an invalid answer\n\n#### setFlow(flow)\n\nSet the parent flow\n* flow *(Flow)* - Flow instance\n\n#### setSubFlow(subFlow)\n\nSet the sub flow to execute after this question\n* subFlow *(Flow)* - Flow instance\n\n#### setFormatAnswerFunction(callback)\n\nSet a format function to format given answer with\n* callback *(Function(answerValue))* - Callback that is called when an answer is given\n  * answerValue *(Object)* - Value of the answer\n  \n  returns *(Object)* - Formatted answer\n\n#### setFormatQuestionFunction(callback)\n\nSet a format question text callback function\n* callback *(Function(answers))* - Callback that is called before the question is asked\n  * answers *(Answers)* - Answers instance\n  \n  returns *(String)* - Formatted question text to send\n\n#### setSummaryFunction(callback)\n\nSet a summary callback function to trigger after answer\n* callback *(Function(answers))* - Callback called when a summary of the given answers is requested\n  * answers *(Answers)* - Answers instance\n\n  returns *(String)* - Summary text to send\n\n#### setDelay(ms)\n\nUse a delay before executing the last added question\n* ms *(Integer)* - Milliseconds to delay question\n\n#### setTimeout(ms, text, callback)\n\nUse non-default timeout settings for this question\n* ms *(Integer)* - Milliseconds to wait for response\n* text *(String)* - Optional override timeout text to send\n* callback *(Function())* - Optional override timeout callback to call\n\n#### setMentionAnswerKey(mentionAnswerKey)\n\nAsk this question to users that were mentioned earlier\n* mentionAnswerKey *(String)* - Key used to store the mentions with in Answers\n\n#### setUserIds(userIds)\n\nAsk this question to a list of user ids\n* userIds *(Array)* - String array of Alterdesk user ids\n\n#### setBreakOnValue(value, stop)\n\nBreak this multi user question on an answer value and optionally stop the flow\n* value *(Object)* - Value to break on\n* stop *(Boolean)* - Stop flow when breaking\n\n#### setBreakOnRegex(regex, stop)\n\nBreak this multi user question when an answer matches the given regex and optionally stop the flow\n* regex *(RegExp)* - Regular expression to break with\n* stop *(Boolean)* - Stop flow when breaking\n\n#### setBreakOnCount(count)\n\nBreak this multi user question when a certain number of answers is reached\n* count *(Integer)* - Count of answers to break on\n\n#### setMultiUserSummaryFunction(callback)\n\nSet a summary callback function to trigger after every user answer\n* callback *(Function(answers, userId, breaking))* - Callback that is called when a user answers the question\n  * answers *(Answers)* - Answers instance\n  * userId *(String)* - Alterdesk user id of the user that answered\n  * breaking *(Boolean)* - If breaking multi user question because of this answer\n\n  returns *(String)* - Summary text to send\n\n\n### TextQuestion\n#### constructor(answerKey, questionText, invalidText)\n\nCreate a new TextQuestion instance\n* answerKey *(String)* - Key to store answer in Answers instance with\n* questionText *(String)* - Text to send when the question is triggered\n* invalidText *(String)* - Text to send when the user sends an invalid answer\n\n#### setRegex(regex)\n\nUse an alternative regular expression\n* regex *(RegExp)* - Regular expression to check answer with\n\n#### setLength(min, max)\n\nSet the accepted length of the answer\n* min *(Integer)* - Minimum accepted length\n* max *(Integer)* - Maximum accepted length\n\n#### checkAndParseAnswer(matches, message)\n\nCheck if valid text and if length is accepted\n* matches *(Array)* - Array of regular expression matches\n* message *(Message)* - Hubot Message instance\n\n* returns *(String)* - Parsed value when accepted\n\n#### acceptedLength(text)\n\nCheck if the text is within length boundaries\n* text *(String)* - Text to check\n\nreturns *(Boolean)* - Accepted length\n \n### NumberQuestion\n#### constructor(answerKey, questionText, invalidText)\n\nCreate a new NumberQuestion instance\n* answerKey *(String)* - Key to store answer in Answers instance with\n* questionText *(String)* - Text to send when the question is triggered\n* invalidText *(String)* - Text to send when the user sends an invalid answer\n\n#### setRange(min, max)\n\nLimit the valid answer to range\n* min *(Integer)* - Minimum accepted value\n* max *(Integer)* - Maximum accepted value\n\n#### checkAndParseAnswer(matches, message)\n\nParse given number as float and only accept if in range\n* matches *(Array)* - Array of regular expression matches\n* message *(Message)* - Hubot Message instance\n\n* returns *(Integer)* - Parsed value when accepted\n\n#### inRange(value)\n\nCheck if the value is in range\n* value *(Integer)* - Value to check\n\nreturns *(Boolean)* - Accepted value\n\n### EmailQuestion\n#### constructor(answerKey, questionText, invalidText)\n\nCreate a new EmailQuestion instance\n* answerKey *(String)* - Key to store answer in Answers instance with\n* questionText *(String)* - Text to send when the question is triggered\n* invalidText *(String)* - Text to send when the user sends an invalid answer\n\n#### checkAndParseAnswer(matches, message)\n\nCheck for valid email and if domain is allowed\n* matches *(Array)* - Array of regular expression matches\n* message *(Message)* - Hubot Message instance\n\n* returns *(String)* - Parsed email address when accepted\n\n#### addAllowedDomain(domain)\n\nAdd a domain to limit accepted answers to\n* domain *(String)* - Accepted domain\n\n#### addAllowedDomains(domains)\n\nAdd a list of accepted domains\n* domains *(Array)* - String array of accepted domains\n \n### PhoneNumberQuestion\n#### constructor(answerKey, questionText, invalidText)\n\nCreate a new PhoneNumberQuestion instance\n* answerKey *(String)* - Key to store answer in Answers instance with\n* questionText *(String)* - Text to send when the question is triggered\n* invalidText *(String)* - Text to send when the user sends an invalid answer\n\n#### checkAndParseAnswer(matches, message)\n\nCheck if valid phone number and if country code is allowed\n* matches *(Array)* - Array of regular expression matches\n* message *(Message)* - Hubot Message instance\n\n* returns *(String)* - Parsed phone number when accepted\n\n#### addAllowedCountryCode(code)\n\nAdd a country code to limit accepted answers to\n* code *(String)* - Accepted country code\n\n#### addAllowedCountryCodes(codes)\n\nAdd a list of accepted country codes\n* codes *(Array)* - String array of allowed country codes\n\n### MentionQuestion\n#### constructor(answerKey, questionText, invalidText)\n\nCreate a new MentionQuestion instance\n* answerKey *(String)* - Key to store answer in Answers instance with\n* questionText *(String)* - Text to send when the question is triggered\n* invalidText *(String)* - Text to send when the user sends an invalid answer\n\n#### setIncludeMentions(mentions)\n\nInclude these mentions after question is answered\n* mentions *(Array)* - Alterdesk mention user data array to add\n\n#### setAllAllowed(allowed)\n\nChange if if the mentioned all tag is allowed\n* allowed *(Boolean)* - If the mention all tag is allowed\n\n#### setRobotAllowed(allowed)\n\nChange if it is allowed to mention robot\n* allowed *(allowed)* - If tagging the Hubot user id is allowed\n\n#### checkAndParseAnswer(matches, message)\n\nParse mentioned users or mentioned all tags\n* matches *(Array)* - Array of regular expression matches\n* message *(Message)* - Hubot Message instance\n\n* returns *(Array)* - Parsed array of mention data when accepted\n\n### AttachmentQuestion\n#### constructor(answerKey, questionText, invalidText)\n\nCreate a new AttachmentQuestion instance\n* answerKey *(String)* - Key to store answer in Answers instance with\n* questionText *(String)* - Text to send when the question is triggered\n* invalidText *(String)* - Text to send when the user sends an invalid answer\n\n#### checkAndParseAnswer(matches, message)\n\nGet attachments that were sent with the message\n* matches *(Array)* - Array of regular expression matches\n* message *(Message)* - Hubot Message instance\n\n* returns *(Array)* - Parsed array of attachments when accepted\n\n#### inCountRange(value)\n\nCheck if the value is in range\n* value *(Integer)* - Count value\n\nreturns *(Boolean)* - Accepted count\n\n#### inSizeRange(value)\n\nCheck if the value is in range\n* value *(Integer)* - Size value\n\nreturns *(Boolean)* - Accepted size\n\n#### setCountRange(minCount, maxCount)\n\nSet a minimum and/or maximum count of attachments to accept\n* minCount *(Integer)* - Minimum count of attachments\n* maxCount *(Integer)* - Maximum count of attachments\n\n#### setSizeRange(minSize, maxSize)\n\nSet a minimum and/or maximum size to accept\n* minSize *(Integer)* - Minimum file size in bytes\n* maxSize *(Integer)* - Maximum file size in bytes\n\n#### addAllowedExtension(extension)\n\nAdd an extension to limit accepted answers to\n* extension *(String)* - Allowed extension\n\n#### addAllowedExtensions(extensions)\n\nAdd a list of accepted extensions\n* extensions *(Array)* - String array of allowed extensions\n\n### PolarQuestion\n#### constructor(answerKey, questionText, invalidText)\n\nCreate a new PolarQuestion instance\n* answerKey *(String)* - Key to store answer in Answers instance with\n* questionText *(String)* - Text to send when the question is triggered\n* invalidText *(String)* - Text to send when the user sends an invalid answer\n\n#### setPositive(regex, subFlow)\n\nSet the positive answer regex and optional sub flow to start when a positive answer was given\n* regex *(RegExp)* - Regular expression to trigger positive answer\n* subFlow *(Flow)* - Flow to start when positive answer was given\n\n#### setNegative(regex, subFlow)\n\nSet the negative answer regex and optional sub flow to start when a negative answer was given\n* regex *(RegExp)* - Regular expression to trigger negative answer\n* subFlow *(Flow)* - Flow to start when negative answer was given\n\n#### setPositiveButton(name, label, style)\n\nSet the name, label and style of the positive answer button, depends on messenger Api instance\n* name *(String)* - Name of the button, needs to trigger positive regex to function\n* label *(String)* - Label on the button\n* style *(String)* - Optional style of the button (defaults to 'green')\n\n#### setNegativeButton(name, label, style)\n\nSet the name, label and style of the negative answer button, depends on messenger Api instance\n* name *(String)* - Name of the button, needs to trigger negative regex to function\n* label *(String)* - Label on the button\n* style *(String)* - Optional style of the button (defaults to 'red')\n\n#### checkAndParseAnswer(matches, message)\n\nCheck if the positive regex or negative regex matches, and set corresponding sub flow to execute\n* matches *(Array)* - Array of regular expression matches\n* message *(Message)* - Hubot Message instance\n\n* returns *(Boolean)* - Parsed value when accepted\n\n### MultipleChoiceQuestion\n#### constructor(answerKey, questionText, invalidText)\n\nCreate a new MultipleChoiceQuestion instance\n* answerKey *(String)* - Key to store answer in Answers instance with\n* questionText *(String)* - Text to send when the question is triggered\n* invalidText *(String)* - Text to send when the user sends an invalid answer\n\n#### addOption(regex, subFlow, value)\n\nAdd an option answer regex, optional sub flow and optional value \n* regex *(RegExp)* - Regular expression to trigger option answer\n* subFlow *(Flow)* - Flow to start when option answer was given\n* value *(Object)* - Value to set as answer when option answer was given\n\n#### addButton(name, label, style)\n\nAdd a button to the last added MultipleChoiceOption, depends on messenger Api instance\n* name *(String)* - Name of the button, needs to trigger option regex to function\n* label *(String)* - Label on the button\n* style *(String)* - Optional style of the button (defaults to 'theme')\n\n#### checkAndParseAnswer(matches, message)\n\nCheck the if one of the option regex matches, and set the corresponding sub flow to execute\n* matches *(Array)* - Array of regular expression matches\n* message *(Message)* - Hubot Message instance\n\n* returns *(String)* - Parsed value when accepted\n\n### MultipleChoiceOption\n#### constructor(regex, subFlow)\n\nCreate a new MultipleChoiceOption instance(internal use)\n\n### VerificationQuestion\n#### constructor(answerKey, questionText, invalidText)\n\nCreate a new VerificationQuestion instance, depends on messenger Api instance\n* answerKey *(String)* - Key to store answer in Answers instance with\n* questionText *(String)* - Text to send when the question is triggered\n* invalidText *(String)* - Text to send when the user sends an invalid answer\n\n#### setProvider(provider)\n\nSet the identity provider for the verification\n* provider *(String)* - Identity provider to use for verification\n\n#### setVerifiedSubFlow(subFlow)\nSet a sub flow for when a user is verified\n* subFlow *(Flow)* - Flow to start when the user is verified\n\n#### setUnverifiedSubFlow(subFlow)\n\nSet a sub flow for when a user declines verification\n* subFlow *(Flow)* - Flow to start when the user declines verification","readmeFilename":"README.md"}