{"_id":"hubot-chatops-rpc","_rev":"2-d74644a015fa975832e213e306f6e3e0","name":"hubot-chatops-rpc","description":"Easily add RPC endpoints to your hubot","dist-tags":{"latest":"0.0.2"},"versions":{"0.0.1":{"name":"hubot-chatops-rpc","description":"Easily add RPC endpoints to your hubot","version":"0.0.1","author":{"name":"Ben Lavender","email":"blavender@gmail.com"},"license":"MIT","keywords":["RPC chatops"],"repository":{"type":"git","url":"git://github.com/hubot-scripts/hubot-chatops-rpc.git"},"bugs":{"url":"https://github.com/hubot-scripts/hubot-chatops-rpc/issues"},"dependencies":{"named-js-regexp":"1.3.1","time-ago":">=0.1.0","underscore":">=1.4.2"},"peerDependencies":{"hubot":"2.x"},"devDependencies":{"hubot-mock-adapter":"1.0.0","chai":"^2.1.1","coffee-errors":"0.8.6","coffee-script":"1.6.3","grunt":"^0.4.5","grunt-cli":"^0.1.13","grunt-contrib-watch":"~0.6.1","grunt-mocha-test":"~0.12.7","grunt-release":"~0.11.0","hubot":"2.x","matchdep":"~0.3.0","mocha":"^2.1.0","sinon":"^1.13.0","sinon-chai":"^2.7.0"},"main":"index.coffee","scripts":{"test":"grunt test"},"gitHead":"b334c5768277416a7f12fdc25873ce3bd43faa98","homepage":"https://github.com/hubot-scripts/hubot-chatops-rpc#readme","_id":"hubot-chatops-rpc@0.0.1","_shasum":"0bd36558eea680491a3544a71c28c79519e56ff8","_from":".","_npmVersion":"3.10.8","_nodeVersion":"6.9.1","_npmUser":{"name":"bhuga","email":"blavender+npm@gmail.com"},"dist":{"shasum":"0bd36558eea680491a3544a71c28c79519e56ff8","tarball":"https://registry.npmjs.org/hubot-chatops-rpc/-/hubot-chatops-rpc-0.0.1.tgz"},"maintainers":[{"name":"bhuga","email":"blavender+npm@gmail.com"}],"_npmOperationalInternal":{"host":"s3://npm-registry-packages","tmp":"tmp/hubot-chatops-rpc-0.0.1.tgz_1497037591301_0.12619026727043092"},"directories":{}},"0.0.2":{"name":"hubot-chatops-rpc","description":"Easily add RPC endpoints to your hubot","version":"0.0.2","author":{"name":"Ben Lavender","email":"blavender@gmail.com"},"license":"MIT","keywords":["RPC chatops"],"repository":{"type":"git","url":"git://github.com/bhuga/hubot-chatops-rpc.git"},"bugs":{"url":"https://github.com/bhuga/hubot-chatops-rpc/issues"},"dependencies":{"named-js-regexp":"1.3.1","time-ago":">=0.1.0","underscore":">=1.4.2"},"peerDependencies":{"hubot":"2.x"},"devDependencies":{"hubot-mock-adapter":"1.0.0","chai":"^2.1.1","coffee-errors":"0.8.6","coffee-script":"1.6.3","grunt":"^0.4.5","grunt-cli":"^0.1.13","grunt-contrib-watch":"~0.6.1","grunt-mocha-test":"~0.12.7","grunt-release":"~0.11.0","hubot":"2.x","matchdep":"~0.3.0","mocha":"^2.1.0","sinon":"^1.13.0","sinon-chai":"^2.7.0"},"main":"index.coffee","scripts":{"test":"grunt test"},"gitHead":"1135aea2ea2d691f265ca8e08b6b2426950fa645","homepage":"https://github.com/bhuga/hubot-chatops-rpc#readme","_id":"hubot-chatops-rpc@0.0.2","_shasum":"853eb704dfabc799008faa130f3d93aaeacd2c77","_from":".","_npmVersion":"3.10.8","_nodeVersion":"6.9.1","_npmUser":{"name":"bhuga","email":"blavender+npm@gmail.com"},"dist":{"shasum":"853eb704dfabc799008faa130f3d93aaeacd2c77","tarball":"https://registry.npmjs.org/hubot-chatops-rpc/-/hubot-chatops-rpc-0.0.2.tgz"},"maintainers":[{"name":"bhuga","email":"blavender+npm@gmail.com"}],"_npmOperationalInternal":{"host":"s3://npm-registry-packages","tmp":"tmp/hubot-chatops-rpc-0.0.2.tgz_1497305322969_0.29932826152071357"},"directories":{}}},"readme":"# hubot-chatops-rpc\n\nEasily add RPC endpoints to your hubot.\n\nChatops RPC is an extraction of years of experience with Chatops at GitHub. It's\na simple protocol based on JSON-RPC over HTTPS. Chatops RPC pushes all of the\ncode save parsing to a server for processing. This means that chat commands can\nbe written and tested entirely server-side, without any glue code in hubot/node.\n\nThis module is the client in the Chatops RPC protocol. Hubot stores a list of\nservers and the endpoints they offer in his brain.\n\nFor more information, see the [protocol description](#protocol-description)\n\n## Usage\n\nTo add a chatops RPC server, use:\n\n`.rpc add https://example.com/_chatops --prefix example`\n\nThis will add `https://example.com/_chatops` to the list of endpoints. Hubot\nwill poll this endpoint every 10 seconds for commands. All commands from this\nendpoint will require a prefix of `example`.\n\nTo remove a server:\n\n`.rpc remove https://example.com/_chatops`\n\nTo see a server's response:\n\n`.rpc debug https://example.com/_chatops`\n\nCommands from this endpoint will be prefixed with `example`. Assume the endpoint\nexposes an endpoint with the regex `/ping/`. The command will be accessible\nwith:\n\n`.example ping`\n\nHubot will parse long-form arguments, such as `--argument1 foo bar`, and send\nthem to the server as additional arguments. These can be added to any command,\nso `.example ping --reason just because we feel like it` will call the `ping`\nmethod with an extra argument of `{ reason: \"just because we feel like it\"}`.\n\n---\n\n## Protocol Description\n\nCRPC is a client-server protocol; Hubot is a client. Servers expose an endpoint\nlisting available methods. Each endpoint provides a regex to fire on and a\nrelative URL path to execute it.\n\nChatops RPC pushes a lot of complexity to clients. This is a design decision,\nintended to keep the burden of creating new chat commands in existing systems\nas low as possible.\n\n## Listing Commands\n\nA CRPC service listing is an endpoint that exposes JSON including the following\nfields:\n\n * `namespace`: A globally unique namespace for these commands. Clients can use this to uniquely identify this endpoint. A namespace should be a slug of the form `/[a-Z0-9\\-_]+/`.\n * `help`: **Optional:** Overall help for this namespace, if a client chooses to provide help\n * `error_response`: **Optional:** A message to present when this endpoint returns an error. This can direct users to next steps when the server fails.\n * `methods`: A mapping of named operations to their metadata.\n * `version`: The version of ChatOps RPC protocol to use, currently version 3\n\nEach key in the `methods` hash will be a string name. Each name should be a\nslug of the form `/[a-Z0-9]\\-_]+/`. Clients can use these method names to uniquely\nidentify methods within a namespace. Each name shall point to an object with the\nfollowing fields:\n\n * `regex`: A string regular expression source used to execute the command. This regular expression should use named capture groups of the form `(?<parameter_name>.+)`.\n * `path`: A path, relative to the listing URL, to execute the command.\n * `params`: A list of available named parameters for this command.\n * `help`: **Optional:** User help for a given command.\n\nEach server is assumed to be given a prefix, which the client will handle\nprepending to a command's regex source. Clients can use the `namespace` as a\ndefault prefix if they wish, but servers may not demand a particular prefix.\nChatops RPC clients should require whitespace after the prefix, so a command with a\nregex like `/ping/` with a prefix of `test` would match on `test ping`.\n\n## Executing Commands\n\nCRPC clients use the listings to create a listing of available commands. When a\nchat message matches a command's regex matcher, the CRPC client creates a method\ninvocation. A method invocation is a JSON object with the following fields:\n\n * `user`: A slug username corresponding to to the command giver's GitHub login.\n * `room_id`: A slug room name where the command originated.\n * `method`: The method name, without namespace, of the matching regex.\n * `params`: A mapping of parameter names to matches extracted from named capture groups in the command's regex. Parameters that are empty or null should not be passed.\n\nThe JSON object is posted to the `path` associated with the command from the\nlisting of commands. CRPC servers should assume that parameters in the `params`\nhash are under user control, but trust that the `user` and `room_id` to be\ncorrect.\n\nCRPC servers must produce a response JSON object with the following fields:\n\n * `result`: A string to be displayed in the originating chat room.\n\nCRPC may optionally include the following fields in a response JSON object for\nuse in situations where richer results can be displayed. Clients will optionally\nutilize some or all of the extra information to provide an enhanced response,\nbut it is important that `result` be sufficient on its own.\n\n * `title`: The title text for the response\n * `title_link`: Optional URL to link the title text to\n * `color`: Hex color for the message, to indicate status/group e.g. \"ddeeaa'\n * `buttons`: An array of button objects\n    * `label`: The text to display on the button\n    * `image_url`: An image URL to display as the button, will generally take precedence\n    * `command`: The command to use when the button is clicked\n * `image_url`: An image URL to be included with the response\n\nCRPC may also produce error JSON according to the JSON-RPC spec, consisting of\nan object containing an `error` object with a `message` string. This is\nsometimes helpful for clients that make a distinction between failed and\nsuccessful commands, such as a terminal. CRPC point of view. CRPC clients should\nstill parse these error messages.\n\n## Examples\n\nHere is an end-to-end transaction, sans authentication (see below):\n\nCRPC client issues:\n```\nGET /_chatops HTTP/1.1\nAccept: application/json\n\n{\n \"namespace\": \"deploy\",\n \"help\": null,\n \"version\": 3,\n \"error_response\": \"The server had an unexpected error. More information is perhaps available in the [error tracker](https://example.com)\"\n \"methods\": {\n   \"options\": {\n     \"help\": \"hubot deploy options <app> - List available environments for <app>\",\n     \"regex\": \"options(?: (?<app>\\\\S+))?\",\n     \"params\": [\n       \"app\"\n     ],\n     \"path\": \"wcid\"\n   }\n }\n}\n```\n\nThe client will use the suggested `namespace` as a prefix, `deploy`. Thus, when\nthe client receives a command matching `.deploy options hubot`, the CRPC client\nissues:\n\n```\nPOST /_chatops/wcid HTTP/1.1\nAccept: application/json\nContent-type: application/json\nContent-length: 77\n\n{\"user\":\"bhuga\",\"method\":\"wcid\",\"params\":{\"app\": \"hubot\"},\"room_id\":\"developer-experience\"}\n```\n\nThe CRPC server should respond with output like the following:\n\n```\n{\"result\":\"Hubot is unlocked in production, you're free to deploy.\\nHubot is unlocked in staging, you're free to deploy.\\n\"}\n```\n\nThe CRPC client should output \"Hubot is unlocked in production, you're free to\ndeploy.\\nHubot is unlocked in staging, you're free to deploy.\\n\" to the chat\nroom. The client can optionally display the output intelligently if it contains\nnewlines, links in formats like markdown, etc. It's strongly recommended that\na client support markdown links if possible.\n\n## Authentication\n\n#### Authenticating clients\n\nClients authenticate themselves to servers by signing requests with RS256\nusing a private key. Servers have a public key associated with clients and\nverify the signature with it.\n\nBy convention, a CRPC server should allow authentication with two secrets\nsimultaneously to allow seamless token rolling.\n\nClients send three additional HTTP headers for authentication: `Chatops-Nonce`,\n`Chatops-timestamp`, and `Chatops-Signature`.\n\n * `Chatops-Nonce`: A random, base64-encoded string unique to every chatops\n request. Servers can cache seen nonces and refuse to execute them a second time.\n * `Chatops-Timestamp`: An ISO 8601 time signature in UTC, such as\n `2017-05-11T19:15:23Z`.\n * `Chatops-Signature`: The signature for this request.\n\nThe value to be signed is formed by concatenating the value of the full http path,\nfollowed by a newline character, followed by the contents of the nonce\nheader, followed by a newline character, followed by the value of the timestamp header,\nfollowed by a newline character, followed by the entire HTTP post body, if any. For example,\nfor a `GET` request with these headers:\n\n```\nChatops-Nonce: abc123\nChatops-Timestamp: 2017-05-11T19:15:23Z\n```\n\nSent to the following URL:\n\n`https://example.com/_chatops`\n\nThe string to be signed is:\n`https://example.com/_chatops\\nabc123\\n2017-05-11T19:15:23Z\\n`\n\nFor a request with the same headers and a POST body of `{\"method\": \"foo\"}`, the\nstring to be signed is:\n\n`https://example.com/_chatops\\nabc123.2017-05-11T19:15:23Z\\n{\"method\": \"foo\"}`\n\nThe signature header starts with the word `Signature`, followed by whitespace,\nfollowed by comma-separated key-value pairs separated by an `=`. Each\nvalue is closed with double quotes. Keys must be all lowercase.\n\n * `keyid`: An implementation-specific key identifier that servers can use to\n determine which private key signed this request.\n * `signature`: The base64-encoded RSA-SHA256 signature of the signing string.\n\nAn example signature header would be:\n\n`Chatops-Signature: Signature keyid=\"rsakey1\",signature=\"<base64-encoded-signature>\"`\n\n#### Authentication\n\nCRPC must trust that a user is authenticated by the `user` parameter sent with\nevery command. Individual servers may request a second authentication factor\nafter receiving a command; this is beyond the scope of CRPC.\n\n#### Authorization\n\nCRPC servers are responsible for ensuring that the given `user` has the proper\nauthorization to perform an operation.\n\n### Execution\n\nChatops RPC clients are expected to add a few niceties not covered by the wire\nprotocol. This complexity is exported to clients to keep the burden of\nimplementing new automation low.\n\n * Regex anchoring. Clients should anchor regexes received from servers. If a\n command is exported as `where can i deploy`, it should not be triggered on\n `tell me where i can deploy` or `where can i deploy, i'm bored`.\n * Prefixing. Different execution contexts may prefix commands, such as `.`,\n `hubot`, or another sigil.\n * Help display systems. These are heavily context dependent. Servers provide\n text snippets about commands, but accessing and displaying them is up to the\n client.\n\nThese niceties are optional and context-dependent. Different clients may or may\nnot implement them. But if any of these are required in any execution context,\nthey should not be pushed to the server.\n\n### Protocol Changes\n\nThe version of the ChatopsRPC protocol in use by a server is given as the\n`version` field. If no version is returned, `3` is assumed.\n\n---\n\n## Server Implementations\n\n * [chatops-controller]() makes it easy to add CRPC endpoints to rails applications.\n\n## Installation\n\nIn hubot project repo, run:\n\n`npm install hubot-chatops-rpc --save`\n\nThen add **hubot-chatops-rpc** to your `external-scripts.json`:\n\n```json\n[\n  \"hubot-chatops-rpc\"\n]\n```\n\nCreate a public/private key pair for authentication:\n\n```\nssh-keygen -t rsa -b 4096 -f crpc\n```\n\nThis will create two files, `crpc` and `crpc.pub`. Use the contents of the\n`crpc` file as an environment variable, `CHATOPS_PRIVATE_KEY`. `crpc.pub`\ncontains a public key for use by servers.\n\n## NPM Module\n\nhttps://www.npmjs.com/package/hubot-chatops-rpc\n","maintainers":[{"name":"bhuga","email":"blavender+npm@gmail.com"}],"time":{"modified":"2017-06-12T22:08:44.054Z","created":"2017-06-09T19:46:32.459Z","0.0.1":"2017-06-09T19:46:32.459Z","0.0.2":"2017-06-12T22:08:44.054Z"},"homepage":"https://github.com/bhuga/hubot-chatops-rpc#readme","keywords":["RPC chatops"],"repository":{"type":"git","url":"git://github.com/bhuga/hubot-chatops-rpc.git"},"author":{"name":"Ben Lavender","email":"blavender@gmail.com"},"bugs":{"url":"https://github.com/bhuga/hubot-chatops-rpc/issues"},"license":"MIT","readmeFilename":"README.md","_attachments":{}}